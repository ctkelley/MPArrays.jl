<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Half Precision and GMRES-IR · MultiPrecisionArrays.jl</title><meta name="title" content="Half Precision and GMRES-IR · MultiPrecisionArrays.jl"/><meta property="og:title" content="Half Precision and GMRES-IR · MultiPrecisionArrays.jl"/><meta property="twitter:title" content="Half Precision and GMRES-IR · MultiPrecisionArrays.jl"/><meta name="description" content="Documentation for MultiPrecisionArrays.jl."/><meta property="og:description" content="Documentation for MultiPrecisionArrays.jl."/><meta property="twitter:description" content="Documentation for MultiPrecisionArrays.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultiPrecisionArrays.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">GMRES-IR</span><ul><li class="is-active"><a class="tocitem" href>Half Precision and GMRES-IR</a><ul class="internal"><li><a class="tocitem" href="#Half-Precision-is-Subtle"><span>Half Precision is Subtle</span></a></li><li><a class="tocitem" href="#GMRES-IR"><span>GMRES-IR</span></a></li></ul></li></ul></li><li><span class="tocitem">More than you want to know</span><ul><li><a class="tocitem" href="../Details/Termination/">Terminating the while loop</a></li><li><a class="tocitem" href="../Details/Interprecision_1/">Interprecision Transfers: Part I</a></li></ul></li><li><span class="tocitem">MPArray Constructors</span><ul><li><a class="tocitem" href="../functions/MPArray/">MPArray: constructor</a></li><li><a class="tocitem" href="../functions/MPGArray/">MPGArray: constructor</a></li></ul></li><li><span class="tocitem">Factorizations</span><ul><li><a class="tocitem" href="../functions/hlu!/">hlu!: Get LU to perform reasonably well for Float16</a></li><li><a class="tocitem" href="../functions/mplu!/">mplu!: Simple MPArray factorization</a></li><li><a class="tocitem" href="../functions/mplu/">mplu: Combine MPArray construction and factorization</a></li><li><a class="tocitem" href="../functions/mpglu!/">mpglu!: Factor a MPGArray and set it up for GMRES y allocating room</a></li><li><a class="tocitem" href="../functions/mpglu/">mpglu: Combine MPGArray construction and factorization</a></li></ul></li><li><span class="tocitem">Iteration Statistics</span><ul><li><a class="tocitem" href="../Details/Stats/">Harvesting Iteration Statistics</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../functions/mpgeslir/">mpgeslir: IR solver</a></li><li><a class="tocitem" href="../functions/mpgmir/">mpgmir: GMRES-IR solver</a></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../References/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">GMRES-IR</a></li><li class="is-active"><a href>Half Precision and GMRES-IR</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Half Precision and GMRES-IR</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ctkelley/MultiPrecisionArrays.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ctkelley/MultiPrecisionArrays.jl/blob/main/docs/src/Half_1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Half-Precision-and-GMRES-IR"><a class="docs-heading-anchor" href="#Half-Precision-and-GMRES-IR">Half Precision and GMRES-IR</a><a id="Half-Precision-and-GMRES-IR-1"></a><a class="docs-heading-anchor-permalink" href="#Half-Precision-and-GMRES-IR" title="Permalink"></a></h1><p>Using half precision will not speed anything up, in fact it will make  the solver slower. The reason for this is that LAPACK and the BLAS  do not (<strong>YET</strong>) support half precision, so all the clever stuff in there is missing. We provide a half precision LU factorization <strong>/src/Factorizations/hlu!.jl</strong> that is better than nothing.  It&#39;s a hack of Julia&#39;s  <code>generic_lu!</code> with threading and a couple compiler directives. Even so, it&#39;s 2.5 – 5 x <strong>slower</strong> than a  double precision LU. Half precision support is coming  (Julia and Apple support it in hardware!) but for now, at least for desktop computing, half precision is for research in iterative refinement, not applications. </p><p>Here&#39;s a table (created with  <strong>/Code<em>For</em>Docs/HalfTime.jl</strong> ) that illustrates the point. In the table we compare timings for LAPACK&#39;s LU to the LU we compute with <code>hlu!.jl</code>. The matrix is  <span>$I-800.0*G$</span>.</p><pre><code class="nohighlight hljs">      N       F64       F32       F16     F16/F64 
     1024  3.65e-03  2.65e-03  5.26e-03  1.44e+00 
     2048  2.26e-02  1.41e-02  3.70e-02  1.64e+00 
     4096  1.55e-01  8.53e-02  2.55e-01  1.65e+00 
     8192  1.15e+00  6.05e-01  4.23e+00  3.69e+00 </code></pre><p>The columns of the table are the dimension of the problem, timings for double, single, and half precision, and the ratio of the half precision timings to double. The timings came from Julia 1.10-beta2 running on an Apple M2 Pro with 8 performance cores.</p><h2 id="Half-Precision-is-Subtle"><a class="docs-heading-anchor" href="#Half-Precision-is-Subtle">Half Precision is Subtle</a><a id="Half-Precision-is-Subtle-1"></a><a class="docs-heading-anchor-permalink" href="#Half-Precision-is-Subtle" title="Permalink"></a></h2><p>Half precision is also difficult to use properly. The low precision can  make iterative refinement fail because the half precision factorization  can have a large error. Here is an example to illustrate this point.  The matrix here is modestly ill-conditioned and you can see that in the  error from a direct solve in double precision.</p><pre><code class="nohighlight hljs">julia&gt; A=I - 800.0*G;

julia&gt; x=ones(N);

julia&gt; b=A*x;

julia&gt; xd=A\b;

julia&gt; norm(b-A*xd,Inf)
6.96332e-13

julia&gt; norm(xd-x,Inf)
2.30371e-12</code></pre><p>Now, if we downcast things to half precision, nothing good happens.</p><pre><code class="nohighlight hljs">julia&gt; AH=Float16.(A);

julia&gt; AHF=hlu!(AH);

julia&gt; z=AHF\b;

julia&gt; norm(b-A*z,Inf)
6.25650e-01

julia&gt; norm(z-xd,Inf)
2.34975e-01</code></pre><p>So you get very poor, but unsurprising, results. While <strong>MultiPrecisionArrays.jl</strong> supports half precision and I use it all the time, it is not something you would use in your own work without looking at the literature and making certain you are prepared for strange results. Getting good results consistently from half precision is an active research area.</p><p>So, it should not be a surprise that IR also struggles with half precision. We will illustrate this with one simple example. In this example high precision will be single and low will be half. Using {\bf MPArray} with a single precision matrix will automatically make the low precision matrix half precision.</p><pre><code class="nohighlight hljs">julia&gt; N=4096; G=800.0*Gmat(N); A=I - Float32.(G);

julia&gt; x=ones(Float32,N); b=A*x;

julia&gt; MPF=mplu(A; onthefly=false);

julia&gt; y=MPF\b;

julia&gt; norm(b - A*y,Inf)
1.05272e+02</code></pre><p>So, IR completely failed for this example. We will show how to extract the details of the iteration in a later section.</p><p>It is also worthwhile to see if doing the triangular solves on-the-fly (MPS) helps. </p><pre><code class="nohighlight hljs">julia&gt; MPBF=mplu(A);

julia&gt; z=MPBF\b;

julia&gt; norm(b-A*z,Inf)
1.28174e-03</code></pre><p>So, MPS is better in the half precision case. Moreover, it is also less costly thanks to the limited support for half precision computing. For that reason, MPS is the default when high precision is single.</p><p>However, on-the-fly solves are not enough to get good results and IR still terminates too soon.</p><h2 id="GMRES-IR"><a class="docs-heading-anchor" href="#GMRES-IR">GMRES-IR</a><a id="GMRES-IR-1"></a><a class="docs-heading-anchor-permalink" href="#GMRES-IR" title="Permalink"></a></h2><p>GMRES-IR solves the correction equation with a preconditioned GMRES iteration. One way to think of this is that the solve in the IR loop is an approximate solver for the correction equation</p><p class="math-container">\[A d = r\]</p><p>where one replaces <span>$A$</span> with the low precision factors <span>$LU$</span>. In GMRES-IR one solves the correction equation with a left-preconditioned GMRES iteration using <span>$U^{-1} L^{-1}$</span> as the preconditioner. The preconditioned equation is</p><p class="math-container">\[U^{-1} L^{-1}  A d = U^{-1} L^{-1} r.\]</p><p>GMRES-IR will not be as efficient as IR because each iteration is itself an GMRES iteration and application of the preconditioned matrix-vector product has the same cost (solve + high precision matrix vector product) as a single IR iteration. However, if low precision is half, this approach can recover the residual norm one would get from a successful IR iteration.</p><p>There is also a storage problem. One should allocate storage for the Krylov basis vectors and other vectors that GMRES needs internally. We do that in the factorization phase. So the structure {\bf MPGEFact} has the  factorization of the low precision matrix, the residual, the Krylov basis and some other vectors needed in the solve. </p><p>The Julia function <code>mpglu</code> constructs the data structure and factors the low precision copy of the matrix. The output, like that of <code>mplu</code> is a factorization object that you can use with backslash.</p><p>Here is a well conditioned example. Both IR and GMRES-IR perform well, with GMRES-IR taking significantly more time.  </p><pre><code class="nohighlight hljs">julia&gt; using MultiPrecisionArrays

julia&gt; using MultiPrecisionArrays.Examples

julia&gt; using BenchmarkTools

julia&gt; N=4069; AD= I - Gmat(N); A=Float32.(AD); x=ones(Float32,N); b=A*x;

julia&gt; MPF=mplu(A); MPF2=mpglu(A);

julia&gt; z=MPF\b; y=MPF2\b; println(norm(z-x,Inf),&quot;  &quot;,norm(y-x,Inf))
5.9604645e-7  4.7683716e-7

julia&gt; @btime $MPF\$b;
  13.582 ms (4 allocations: 24.33 KiB)

julia&gt; @btime $MPF2\$b;
  40.344 ms (183 allocations: 90.55 KiB)</code></pre><p>If you dig into the iterations statistics (more on that later) you will see that the GMRES-IR iteration took almost exactly four times as many solves and residual computations as the simple IR solve.</p><p>We will repeat this experiment on the ill-conditioned example. In this example, as we saw earlier, IR fails to converge.</p><pre><code class="nohighlight hljs">julia&gt; N=4069; AD= I - 800.0*Gmat(N); A=Float32.(AD); x=ones(Float32,N); b=A*x;
        
julia&gt; MPF=mplu(A); MPF2=mpglu(A);

julia&gt; z=MPF\b; y=MPF2\b; println(norm(z-x,Inf),&quot;  &quot;,norm(y-x,Inf))
0.2875508  0.004160166

julia&gt; println(norm(b-A*z,Inf)/norm(b,Inf),&quot;  &quot;,norm(b-A*y,Inf)/norm(b,Inf))
0.0012593127  1.4025759e-5</code></pre><p>So, the relative error and relative residual norm for GMRES-IR is much smaller than that for IR.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Details/Termination/">Terminating the while loop »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 5 December 2023 16:50">Tuesday 5 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
